# Instance layout
method.insert = cfg.basedir, private|const|string, (cat,"/data/rtorrent/")
method.insert = cfg.download, private|const|string, (cat,"/downloads/")
method.insert = cfg.download_complete, private|const|string, (cat,(cfg.download),"complete/")
method.insert = cfg.download_temp, private|const|string, (cat,(cfg.download),"temp/")
method.insert = cfg.logs, private|const|string, (cat,(cfg.basedir),"log/")
method.insert = cfg.session, private|const|string, (cat,(cfg.basedir),".session/")
method.insert = cfg.watch, private|const|string, (cat,(cfg.basedir),"watch/")
method.insert = cfg.rundir, private|const|string, (cat,"/var/run/rtorrent/")

# Gets the full path of data of a torrent (it's a workaround for the possibly empty 'd.base_path' attribute)
method.insert = d.data_path, simple, "if=(d.is_multi_file), (cat,(d.directory),/), (cat,(d.directory),/,(d.name))"

# Default directory to save the downloaded torrents
directory.default.set = (cat,(cfg.download_temp))

# Default session directory
session.path.set = (cat,(cfg.session))

# PID file
execute.nothrow = sh,-c,(cat,"echo >",(cfg.rundir),"rtorrent.pid"," ",(system.pid))

# SCGI socket and make it group-writable and secure
network.scgi.open_local = (cat, (cfg.rundir), "scgi.socket")
schedule2 = scgi_permission, 0, 0, (cat,"execute.nothrow=chmod,\"g+w,o=\",",(cfg.rundir),"scgi.socket")

# Listening port for incoming peer traffic
network.port_range.set = @RT_INC_PORT@-@RT_INC_PORT@
network.port_random.set = no

# UDP port to use for DHT
dht.port.set = @RT_DHT_PORT@

# XMLRPC size limit
network.xmlrpc.size_limit.set = @XMLRPC_SIZE_LIMIT@

# Configure session saving interval to balance disk usage and torrent information accuracy
schedule2 = session_save, 1200, @RT_SESSION_SAVE_SECONDS@, ((session.save))

# Save torrents immediately to prevent losing them between session saving intervals
# Schedule task to run in background (with unique hash) to avoid seeding impact
method.set_key = event.download.inserted_new, "schedule2 = ((d.hash)), 0, 0, ((d.save_full_session))"

# Configure whether to delay tracker announces at startup
trackers.delay_scrape = @RT_TRACKER_DELAY_SCRAPE@

# Configure TCP rmem and wmem for rTorrent client
network.send_buffer.size.set = @RT_SEND_BUFFER_SIZE@
network.receive_buffer.size.set = @RT_RECEIVE_BUFFER_SIZE@

# Configure preallocation feature for rTorrent client
system.file.allocate.set = @RT_PREALLOCATE_TYPE@

# Logging
## levels = critical error warn notice info debug
## groups = connection_* dht_* peer_* rpc_* storage_* thread_* tracker_* torrent_*
log.open_file = "log",(cat,(cfg.logs),"rtorrent.log")
log.add_output = "@RT_LOG_LEVEL@","log"
log.add_output = "rpc_events","log"
#log.execute = (cat,(cfg.logs),"execute.log")
#log.xmlrpc = (cat,(cfg.logs),"xmlrpc.log")

# Initialize plugins
execute2 = {sh,-c,/usr/bin/php84 /var/www/rutorrent/php/initplugins.php rtorrent &}

## original rc starts here
# Maximum and minimum number of peers to connect to per torrent
throttle.min_peers.normal.set = 1
throttle.max_peers.normal.set = 100

# Same as above but for seeding completed torrents (-1 = same as downloading)
throttle.min_peers.seed.set = 1
throttle.max_peers.seed.set = 50

# Maximum number of simultanious uploads per torrent
throttle.max_uploads.set = 15

# Global upload and download rate in KiB. "0" for unlimited
throttle.global_down.max_rate.set_kb = 0
throttle.global_up.max_rate.set_kb = 0

# Enable DHT support for trackerless torrents or when all trackers are down
# May be set to "disable" (completely disable DHT), "off" (do not start DHT),
# "auto" (start and stop DHT as needed), or "on" (start DHT immediately)
dht.mode.set = auto

# Enable peer exchange (for torrents not marked private)
protocol.pex.set = yes

# Check hash for finished torrents. Might be usefull until the bug is
# fixed that causes lack of diskspace not to be properly reported
pieces.hash.on_completion.set = yes

# Set whether the client should try to connect to UDP trackers
#trackers.use_udp.set = yes

# Set the max amount of memory address space used to mapping file chunks. This refers to memory mapping, not
# physical memory allocation. Default: 1GB (max_memory_usage)
# This may also be set using ulimit -m where 3/4 will be allocated to file chunks
#pieces.memory.max.set = 1GB

# Alternative calls to bind and ip that should handle dynamic ip's
#schedule2 = ip_tick,0,1800,ip=rakshasa
#schedule2 = bind_tick,0,1800,bind=rakshasa

# Encryption options, set to none (default) or any combination of the following:
# allow_incoming, try_outgoing, require, require_RC4, enable_retry, prefer_plaintext
protocol.encryption.set = allow_incoming,try_outgoing,enable_retry

# Set the umask for this process, which is applied to all files created by the program
system.umask.set = 0022

# Add a preferred filename encoding to the list
encoding.add = UTF-8

# Watch a directory for new torrents, and stop those that have been deleted
directory.watch.added = (cat,(cfg.watch)), load.start
schedule2 = untied_directory, 5, 5, (cat,"stop_untied=",(cfg.watch),"*.torrent")

# Close torrents when diskspace is low
schedule2 = monitor_diskspace, 15, 60, ((close_low_diskspace,1000M))

# Move finished (no need Autotools/Automove plugin on ruTorrent)
method.insert = d.get_finished_dir, simple, "cat=$cfg.download_complete=,$d.custom1="
method.insert = d.move_to_complete, simple, "d.directory.set=$argument.1=; execute=mkdir,-p,$argument.1=; execute=mv,-u,$argument.0=,$argument.1=; d.save_full_session="
method.set_key = event.download.finished,move_complete,"d.move_to_complete=$d.data_path=,$d.get_finished_dir="

### rtorrent settings #######################################################
#                                                              vim: ft=dosini
# This is the standard configuration that supports both PyroScope and
# (optionally) rTorrent-PS features.
#
# It is installed by Ansible, but only gets overwritten when you provide the
# option "-e force_cfg=yes" to the "ansible-playbook" command, after the
# initial playbook run.
#
# For more info regarding changing configuration defaults, see the docs:
#
#   https://pimp-my-box.readthedocs.io/en/latest/setup.html#change-cfg-defaults
#
#############################################################################

# Root directory of this instance (RT_HOME is set in the "start" script).
# With vanilla rTorrent, must be changed to something like…
#   … string, (cat,"/var/torrent/")
method.insert = cfg.basedir, private|const|string, (cat,(system.env,"RT_HOME"),"/")

# `system.has` polyfill (the "false=" silences the `catch` command, in rTorrent-PS 1.1+)
catch = {"false=", "method.redirect=system.has,false"}

# Set "pyro.extended" to 1 to activate rTorrent-PS features!
method.insert = pyro.extended, const|value, (system.has, rtorrent-ps)

# Set "pyro.bin_dir" to the "bin" directory where you installed the pyrocore tools!
# Make sure you end it with a "/"; if this is left empty, then the shell's path is searched.
method.insert = pyro.bin_dir, const|string, /opt/pyrocore/.local/pyroscope/bin/

# Set this to '0' to prevent logging of existing key bindings being replaced
## branch=(pyro.extended), ((ui.bind_key.verbose.set, 0))

# Since "network.scgi.open_local" is parsed by "rtcontrol", this must be a literal value,
# and also not moved out of the main configuration file!
network.scgi.open_local = /var/torrent/.scgi_local

# SCHEDULE: Make SCGI socket group-writable and secure
schedule2 = scgi_permission, 0, 0, "execute.nothrow=chmod,\"g+w,o=\",/var/torrent/.scgi_local"


#
# Import settings from "~/rtorrent/rtorrent.d"
#
# Prefer to put your own custom settings into additional files in
# that directory, or else "_rtlocal.rc" (see below)!
#

# Uncomment the following line for debugging purposes only
#log.execute = (cat, /tmp/rtorrent-bootstrap-, (system.pid), .log)
execute.throw = (cat,(pyro.bin_dir),pyroadmin),-q,--create-import,(cat,(cfg.basedir),"rtorrent.d/*.rc")
import = (cat,(cfg.basedir),"rtorrent.d/.import.rc")


#
# Include custom / optional settings
#

# INCLUDE: Local settings (optional)
try_import = (cat,(cfg.basedir),"_rtlocal.rc")

# INCLUDE: ruTorrent (optional)
try_import = (cat,(cfg.basedir),"_rutorrent.rc")

### END rtorrent.rc #########################################################